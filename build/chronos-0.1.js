// Generated by CoffeeScript 1.3.1

window.chronos = {};

chronos.Chronos = (function() {

  Chronos.name = 'Chronos';

  function Chronos() {
    this.current = null;
    this.activePicker = null;
    this.expiredPickers = [];
    this.initialize();
  }

  Chronos.PROP_NAME = 'chronos_element_settings';

  Chronos._defaultOptions = {
    pickerClass: '',
    dayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    dayNamesAbbr: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    monthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    amLower: 'am',
    amUpper: 'AM',
    amAbbrLower: 'a',
    amAbbrUpper: 'A',
    pmLower: 'pm',
    pmUpper: 'PM',
    pmAbbrLower: 'p',
    pmAbbrUpper: 'P',
    startBlank: false,
    displayFormat: 'isoDate',
    valueFormat: 'U',
    maxDate: void 0,
    minDate: void 0,
    startDay: 0,
    pickedDateTime: void 0,
    animations: {},
    positionOffset: {
      top: 0,
      left: 0
    },
    debug: false
  };

  Chronos.events = ['opened', 'closed', 'daySelected', 'previousMonthFinished', 'nextMonthFinished', 'invalidDate', 'validDate'];

  /*
      PUBLIC METHODS
  */


  Chronos.prototype.initialize = function() {
    var _this = this;
    return $(document).mousedown(function(event) {
      return _this._externalClickClose(event);
    });
  };

  Chronos.prototype.setCurrentElement = function(element) {
    this._expirePicker();
    return this.current = $.data(element, chronos.Chronos.PROP_NAME);
  };

  Chronos.prototype.setDateRange = function(range) {
    if (this.current.activePicker) {
      return this.current.activePicker.setDateRange(range);
    } else {
      if (range.minDate) {
        this.current.options.minDate = range.minDate;
      }
      if (range.maxDate) {
        this.current.options.maxDate = range.maxDate;
      }
      return this._saveCurrentSettings();
    }
  };

  /*
      Private methods
  */


  Chronos.prototype._saveCurrentSettings = function() {
    return $.data(this.current.displayElement, chronos.Chronos.PROP_NAME, this.current);
  };

  Chronos.prototype._attach = function(element, options) {
    var $de;
    this.current = {
      options: $.extend({}, chronos.Chronos._defaultOptions, options),
      valueElement: element
    };
    $de = this._buildDisplayElement();
    this.current.displayElement = $de[0];
    this._saveCurrentSettings();
    return this;
  };

  Chronos.prototype._buildDisplayElement = function() {
    var $displayElement, $ve, df, displayClass, initValue, s,
      _this = this;
    s = this.current.options;
    df = new chronos.DateFormatter(s);
    $ve = $(this.current.valueElement);
    initValue = $ve.val();
    initValue = initValue ? df.format(initValue, s.displayFormat) : s.startBlank ? "" : this.current.options.pickedDateTime ? df.format(this.current.options.pickedDateTime, s.displayFormat) : df.format(new Date(), s.displayFormat);
    displayClass = "chronos_picker_display";
    if (this.current.options.pickerClass) {
      displayClass += " " + this.current.options.pickerClass + "_display";
    }
    $displayElement = $ve.clone(true).removeAttr('name').attr('id', $ve.attr('id') + '_display').addClass(displayClass).val(initValue);
    if (!s.debug) {
      $ve.hide();
    }
    $displayElement.bind({
      'focus': function(event) {
        return _this._onFocus(event);
      },
      'keyup': function(event) {
        return _this._onDisplayKeyUp(event);
      },
      'keydown': function(event) {
        return _this._onDisplayKeyDown(event);
      }
    });
    $ve.before($displayElement);
    this.current.displayElement = $displayElement[0];
    return $displayElement;
  };

  Chronos.prototype._renderPicker = function() {
    if (!this.current.activePicker) {
      this._createPicker();
    }
    this.current.activePicker.render();
    this.current.activePicker.insertAfter($(this.current.displayElement));
    return this.current.activePicker;
  };

  Chronos.prototype._createPicker = function() {
    var picker,
      _this = this;
    picker = new chronos.Picker(this.current);
    this.current.activePicker = picker;
    picker.$container.on({
      'internal_close': function(event) {
        return _this._onClose(event);
      }
    });
    return picker;
  };

  Chronos.prototype._expirePicker = function() {
    if (this.current.activePicker) {
      this.expiredPickers.push(this.current.activePicker);
    }
    return this.current.activePicker = null;
  };

  Chronos.prototype._closePickers = function() {
    var picker, _results;
    _results = [];
    while (this.expiredPickers.length > 0) {
      picker = this.expiredPickers.pop();
      _results.push(picker.close());
    }
    return _results;
  };

  Chronos.prototype._directClose = function() {
    this._expirePicker();
    return this._closePickers();
  };

  Chronos.prototype._findPickerFromEvent = function(event) {
    var $picker, $target;
    $target = $(event.target);
    return $picker = $target.hasClass('chronos_picker') ? $target : $target.parents('.chronos_picker');
  };

  Chronos.prototype._notActivePicker = function($picker, event) {
    return $picker.length > 0 && $picker[0] !== this.current.activePicker.$container[0];
  };

  Chronos.prototype._noPickerButActive = function($picker) {
    return $picker.length <= 0 && (this.current.activePicker !== null && this.current.activePicker !== void 0);
  };

  Chronos.prototype._notActiveDisplay = function(event) {
    if (this.current.activePicker) {
      return this.current.activePicker.$displayElement[0] !== event.target;
    } else {
      return true;
    }
  };

  Chronos.prototype._externalClickClose = function(event) {
    var $picker;
    if (this.current) {
      $picker = this._findPickerFromEvent(event);
      if (this._notActiveDisplay(event) && (this._notActivePicker($picker, event) || this._noPickerButActive($picker))) {
        return this._directClose();
      }
    }
  };

  Chronos.prototype._isCurrentPicker = function(target) {
    return this.current.activePicker !== void 0 && this.current.activePicker !== null && this.current.activePicker.$displayElement[0] === target;
  };

  /*
      EVENT HANDLERS
  */


  Chronos.prototype._onFocus = function(event) {
    if (!this._isCurrentPicker(event.target)) {
      this.setCurrentElement(event.target);
      return this._renderPicker();
    }
  };

  Chronos.prototype._onClose = function(event) {
    event.stopPropagation();
    return this._directClose();
  };

  Chronos.prototype._onDisplayKeyUp = function(event) {
    if (this.current.activePicker) {
      return this.current.activePicker.checkAndSetDate();
    }
  };

  Chronos.prototype._onDisplayKeyDown = function(event) {
    if (event.keyCode === 13 || event.keyCode === 27) {
      this.current.activePicker.$displayElement.blur();
    }
    if (event.keyCode === 13 || event.keyCode === 9 || event.keyCode === 27) {
      return this._directClose();
    }
  };

  return Chronos;

})();

chronos.Picker = (function() {

  Picker.name = 'Picker';

  function Picker(current) {
    this.current = current;
    this.$container = void 0;
    this.startingDate = void 0;
    this.mode = void 0;
    this.todayDate = new Date();
    this.pickedDateTime = current.options.pickedDateTime;
    this.$valueElement = $(current.valueElement);
    this.$displayElement = $(current.displayElement);
    this.dateFormatter = new chronos.DateFormatter(current.options);
    this.animator = void 0;
    this._initialize();
  }

  /*
      Public Methods
  */


  Picker.prototype.render = function() {
    this._emptyBody();
    switch (this.mode) {
      case 'year':
        return this._renderYears();
      case 'time':
        return this._renderTime();
      default:
        return this._renderMonths();
    }
  };

  Picker.prototype.close = function() {
    if (!this.closing) {
      this.closing = true;
      return this.animator.close();
    }
  };

  Picker.prototype.insertAfter = function($element) {
    $element.after(this.$container);
    this.setPosition();
    return this.animator.open();
  };

  Picker.prototype.setPosition = function(position) {
    position = position || this._getPosition();
    return this.$container.css(position).css({
      position: "absolute"
    });
  };

  Picker.prototype.setDate = function(date) {
    if ($.isFunction(date.getMonth)) {
      this._saveDate(date);
      return this._updateInputValues();
    }
  };

  Picker.prototype.checkAndSetDate = function() {
    var date;
    date = this.dateFormatter.unformat(this.$displayElement.val(), this.current.options.displayFormat);
    if (date !== false) {
      this._saveDate(date);
      this._updateValueElement();
      this.$container.trigger('validDate');
      return this.render();
    } else {
      return this.$container.trigger('invalidDate');
    }
  };

  Picker.prototype.setDateRange = function(range) {
    if (range.minDate) {
      if (this._isValidDate(range.minDate)) {
        this.current.options.minDate = range.minDate;
        this._saveSettings();
      } else {
        console.warn("chronos: Invalid minDate");
      }
    }
    if (range.maxDate) {
      if (this._isValidDate(range.maxDate)) {
        this.current.options.maxDate = range.maxDate;
        this._saveSettings();
      } else {
        console.warn("chronos: Invalid maxDate");
      }
    }
    return this.render();
  };

  /*
      Private Methods
  */


  Picker.prototype._initialize = function() {
    this._initializeContainer();
    this._initializeAnimator();
    this._setStartingDate();
    this._setPickedDate();
    return this._setInitialMode();
  };

  Picker.prototype._initializeContainer = function() {
    this.$container = this._createContainer();
    this._bindContainerEvents();
    this.$container.append(this._createHeader.call(this));
    this.$container.append(this._createBody.call(this));
    return this.$container;
  };

  Picker.prototype._initializeAnimator = function() {
    this.animator = new chronos.Animator(this, this.current.options.animations);
    this.animator.setPicker(this.$container);
    return this.animator;
  };

  Picker.prototype._saveDate = function(date) {
    this.pickedDateTime = date;
    this.current.pickedDateTime = date;
    return this._saveSettings();
  };

  Picker.prototype._setInitialMode = function() {
    if (this.current.options.useTimePicker && this.current.options.timePickerOnly) {
      return this.mode = 'time';
    } else if (this.current.options.yearOnly) {
      return this.mode = 'year';
    } else {
      return this.mode = 'month';
    }
  };

  Picker.prototype._setStartingDate = function() {
    if (this.current.options.maxDate !== null || this.current.options.minDate !== null) {
      if (this.current.options.maxDate && (this.todayDate.valueOf() > this.current.options.maxDate.valueOf())) {
        this.startingDate = new Date(this.current.options.maxDate.valueOf());
      }
      if (this.current.options.minDate && (this.todayDate.valueOf() < this.current.options.minDate.valueOf())) {
        this.startingDate = new Date(this.current.options.minDate.valueOf());
      }
    }
    if (this.startingDate === void 0) {
      this.startingDate = new Date(this.todayDate.valueOf());
    }
    return this.startingDate;
  };

  Picker.prototype._setPickedDate = function() {
    if (!this.current.options.startBlank) {
      if (this.pickedDateTime === void 0 || this.pickedDateTime === null) {
        return this.pickedDateTime = new Date(this.startingDate.valueOf());
      }
    }
  };

  Picker.prototype._createContainer = function() {
    var klass;
    klass = "chronos_picker";
    if (this.current.options.pickerClass) {
      klass += " " + this.current.options.pickerClass;
    }
    return $("<div class='" + klass + "' />");
  };

  Picker.prototype._createHeader = function() {
    var header, title,
      _this = this;
    header = $('<div class="header"/>');
    header.append($('<div class="previous">&larr;</div>').click(function(event) {
      return _this._onPrevious(event);
    }));
    title = $('<div class="title"/>').click(function(event) {
      return _this._onZoomOut(event);
    });
    title.append($('<span class="titleText"/>'));
    header.append(title);
    header.append($('<div class="next">&rarr;</div>').click(function(event) {
      return _this._onNext(event);
    }));
    return header;
  };

  Picker.prototype._createBody = function() {
    var body;
    body = $('<div class="body" />');
    return body.append($('<div class="body_prev">')).append($('<div class="body_curr">')).append($('<div class="body_next">'));
  };

  Picker.prototype._emptyBody = function() {
    this.$container.find(".body_curr").html("");
    this.$container.find(".body_prev").html("");
    return this.$container.find(".body_next").html("");
  };

  Picker.prototype._renderTitle = function(titleStr) {
    return this.$container.find('.titleText').html(titleStr);
  };

  Picker.prototype._renderMonths = function() {
    var start;
    start = this.pickedDateTime || this.startingDate;
    this._buildMonth(start, this.$container.find(".body_curr"));
    this._renderTitle(this.$container.find(".body_curr").find(".monthBody").attr('data-date_title'));
    this._buildMonth(this._changeMonthBy(start, -1), this.$container.find(".body_prev"));
    return this._buildMonth(this._changeMonthBy(start, 1), this.$container.find(".body_next"));
  };

  Picker.prototype._buildMonth = function(showDate, $container) {
    var month, monthPanel,
      _this = this;
    monthPanel = new chronos.PanelMonth({
      givenDate: showDate,
      startDay: this.current.options.startDay,
      dayNamesAbbr: this.current.options.dayNamesAbbr,
      monthNames: this.current.options.monthNames,
      choice: this.pickedDateTime,
      maxDate: this.current.options.maxDate,
      minDate: this.current.options.minDate
    });
    month = monthPanel.render();
    month.bind('daySelected', function(event, date, dayElement) {
      return _this._onDaySelected(event, dayElement, date);
    });
    return $container.append(month);
  };

  Picker.prototype._changeMonthBy = function(date, value) {
    var d;
    d = new Date(date.valueOf());
    d.setMonth(d.getMonth() + value);
    return d;
  };

  Picker.prototype._saveSettings = function() {
    return $.data(this.current.displayElement, chronos.Chronos.PROP_NAME, this.current);
  };

  Picker.prototype._updateInputValues = function() {
    this._updateValueElement();
    return this._updateDisplayElement();
  };

  Picker.prototype._updateValueElement = function() {
    var d;
    if (this.pickedDateTime) {
      d = this.dateFormatter.format(this.pickedDateTime, this.current.options.valueFormat);
      return this.$valueElement.val(d);
    }
  };

  Picker.prototype._updateDisplayElement = function() {
    var d;
    if (this.pickedDateTime) {
      d = this.dateFormatter.format(this.pickedDateTime, this.current.options.displayFormat);
      return this.$displayElement.val(d);
    }
  };

  Picker.prototype._getWindowHeight = function() {
    return $(window).height();
  };

  Picker.prototype._getScrollTop = function() {
    return $(window).scrollTop();
  };

  Picker.prototype._getPosition = function() {
    var displayAbove, displayBelow, docHeight, lowerDifference, pickerHeight, position, scrollTop, upperDifference;
    position = {
      left: this.$displayElement.offset().left + this.current.options.positionOffset.left,
      top: this.$displayElement.offset().top + this.current.options.positionOffset.top
    };
    docHeight = this._getWindowHeight();
    scrollTop = this._getScrollTop();
    pickerHeight = this.$container.outerHeight();
    lowerDifference = Math.abs(docHeight - position.top + this.$displayElement.outerHeight());
    upperDifference = position.top + scrollTop;
    displayBelow = lowerDifference > pickerHeight;
    displayAbove = upperDifference > pickerHeight;
    if (!displayAbove && !displayBelow) {
      position.top = docHeight / 2 - pickerHeight / 2;
      if (docHeight + scrollTop < pickerHeight) {
        console.warn("chronos: Not enough room to display date picker.");
      }
    } else if (displayBelow) {
      position.top += this.$displayElement.outerHeight();
    } else {
      position.top -= pickerHeight;
    }
    return position;
  };

  Picker.prototype._isValidDate = function(d) {
    return Object.prototype.toString.call(d) === '[object Date]';
  };

  /*
      EVENT HANDLERS
  */


  Picker.prototype._onZoomOut = function(event) {
    return console.log("ZOOM!");
  };

  Picker.prototype._onPrevious = function(event) {
    return this.animator.previousMonth();
  };

  Picker.prototype._onNext = function(event) {
    return this.animator.nextMonth();
  };

  Picker.prototype._onDaySelected = function(event, dayElement, date) {
    if (!this.current.options.useTimePicker) {
      this.pickedDateTime = date;
      this.current.pickedDateTime = date;
      this._saveSettings();
      this._updateInputValues();
      return this.$container.trigger('internal_close');
    } else {

    }
  };

  Picker.prototype._bindContainerEvents = function() {
    var eventType, _i, _len, _ref, _results,
      _this = this;
    _ref = chronos.Chronos.events;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      eventType = _ref[_i];
      _results.push(this.$container.on(eventType, function(event) {
        var a;
        a = Array.prototype.slice.apply(arguments);
        return _this._passEvents(event, a.slice(1, a.length));
      }));
    }
    return _results;
  };

  Picker.prototype._passEvents = function(event, args) {
    event.stopPropagation();
    return this.$valueElement.trigger(event.type, args);
  };

  return Picker;

})();

chronos.DateFormatter = (function() {

  DateFormatter.name = 'DateFormatter';

  function DateFormatter(settings) {
    this.i18n = {
      dayNames: settings.dayNames,
      monthNames: settings.monthNames,
      amLower: settings.amLower,
      amUpper: settings.amUpper,
      amAbbr: settings.amAbbr,
      pmLower: settings.pmLower,
      pmUpper: settings.pmUpper,
      pmAbbr: settings.pmAbbr
    };
  }

  DateFormatter.prototype.masks = {
    "default": "ddd mmm dd yyyy HH:MM:ss",
    shortDate: "d/m/yy",
    USshortDate: "m/d/yy",
    mediumDate: "mmm d, yyyy",
    longDate: "mmmm d, yyyy",
    fullDate: "dddd, mmmm d, yyyy",
    shortTime: "h:MM TT",
    mediumTime: "h:MM:ss TT",
    longTime: "h:MM:ss TT Z",
    isoDate: "yyyy-mm-dd",
    isoTime: "HH:MM:ss",
    isoDateTime: "yyyy-mm-dd'T'HH:MM:ss",
    isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
  };

  DateFormatter.prototype.token = /U{1}|d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g;

  DateFormatter.prototype.timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g;

  DateFormatter.prototype.timezoneClip = /[^-+\dA-Z]/g;

  DateFormatter.prototype.pad = function(val, len) {
    val = String(val);
    len = len || 2;
    while (val.length < len) {
      val = "0" + val;
    }
    return val;
  };

  DateFormatter.prototype.newZeroDate = function() {
    var d;
    d = new Date();
    d.setDate(0);
    d.setMonth(0);
    d.setFullYear(0);
    d.setHours(0);
    d.setMinutes(0);
    d.setSeconds(0);
    d.setMilliseconds(0);
    return d;
  };

  DateFormatter.prototype.unformat = function(dateStr, mask, utc) {
    var dF, date, dateParts, i, maskParts, notCounter, target, targetMask, _, __, _i, _ref;
    dF = this;
    mask = String(dF.masks[mask] || mask || dF.masks["default"]);
    date = this.newZeroDate();
    date.setHours(0);
    maskParts = mask.split(/\W+/);
    dateParts = dateStr.split(/\W+/);
    notCounter = 0;
    _ = (utc ? "setUTC" : "set");
    __ = (utc ? "getUTC" : "get");
    for (i = _i = 0, _ref = maskParts.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      targetMask = maskParts[i];
      target = dateParts[i];
      switch (targetMask) {
        case 'd':
        case 'dd':
          date[_ + 'Date'](target);
          break;
        case 'ddd':
        case 'dddd':
          null;

          break;
        case 'm':
        case 'mm':
          date[_ + 'Month'](parseInt(target) - 1);
          break;
        case 'mmm':
          date[_ + 'Month'](dF.i18n.monthNames.indexOf(target));
          break;
        case 'mmmm':
          date[_ + 'Month'](dF.i18n.monthNames.indexOf(target) - 12);
          break;
        case 'yyyy':
          date[_ + 'FullYear'](target);
          break;
        case 'h':
        case 'hh':
          date[_ + 'Hours'](target % 12 || 12);
          break;
        case 'H':
        case 'HH':
          date[_ + 'Hours'](target);
          break;
        case 'M':
        case 'MM':
          date[_ + 'Minutes'](target);
          break;
        case 's':
        case 'ss':
          date[_ + 'Seconds'](target);
          break;
        case 'l':
        case 'L':
          date[_ + 'Milliseconds'](target);
          break;
        case 't':
          if (dF.i18n.pmAbbrLower === target) {
            date[_ + 'Hours'](date[__ + 'Hours']() + 12);
          }
          break;
        case 'tt':
          if (dF.i18n.pmLower === target) {
            date[_ + 'Hours'](date[__ + 'Hours']() + 12);
          }
          break;
        case 'T':
          if (dF.i18n.pmAbbrUpper === target) {
            date[_ + 'Hours'](date[__ + 'Hours']() + 12);
          }
          break;
        case 'TT':
          if (dF.i18n.pmUpper === target) {
            date[_ + 'Hours'](date[__ + 'Hours']() + 12);
          }
          break;
        case 'Z':
          null;

          break;
        case 'U':
          date[_ + 'Time'](target);
          break;
        default:
          notCounter += 1;
      }
    }
    if (notCounter > 0 || maskParts.length !== dateParts.length) {
      return false;
    } else {
      return date;
    }
  };

  DateFormatter.prototype.format = function(date, mask, utc) {
    var args, dF;
    dF = this;
    args = arguments;
    return (function() {
      var D, H, L, M, U, d, flags, m, o, s, y, _;
      if (args.length === 1 && Object.prototype.toString.call(date) === "[object String]" && !/\d/.test(date)) {
        mask = date;
        date = void 0;
      }
      date = date ? new Date(date) : new Date;
      if (isNaN(date)) {
        throw SyntaxError("invalid date");
      }
      mask = String(dF.masks[mask] || mask || dF.masks["default"]);
      if (mask.slice(0, 4) === "UTC:") {
        mask = mask.slice(4);
        utc = true;
      }
      _ = (utc ? "getUTC" : "get");
      d = date[_ + "Date"]();
      D = date[_ + "Day"]();
      m = date[_ + "Month"]();
      y = date[_ + "FullYear"]();
      H = date[_ + "Hours"]();
      M = date[_ + "Minutes"]();
      s = date[_ + "Seconds"]();
      L = date[_ + "Milliseconds"]();
      o = (utc ? 0 : date.getTimezoneOffset());
      U = date.valueOf();
      flags = {
        d: d,
        dd: dF.pad(d),
        ddd: dF.i18n.dayNames[D],
        dddd: dF.i18n.dayNames[D + 7],
        m: m + 1,
        mm: dF.pad(m + 1),
        mmm: dF.i18n.monthNames[m],
        mmmm: dF.i18n.monthNames[m + 12],
        yy: String(y).slice(2),
        yyyy: y,
        h: H % 12 || 12,
        hh: dF.pad(H % 12 || 12),
        H: H,
        HH: dF.pad(H),
        M: M,
        MM: dF.pad(M),
        s: s,
        ss: dF.pad(s),
        l: dF.pad(L, 3),
        L: dF.pad((L > 99 ? Math.round(L / 10) : L)),
        t: (H < 12 ? dF.i18n.amAbbrLower : dF.i18n.pmAbbrLower),
        tt: (H < 12 ? dF.i18n.amLower : dF.i18n.pmLower),
        T: (H < 12 ? dF.i18n.amAbbrUpper : dF.i18n.pmAbbrUpper),
        TT: (H < 12 ? dF.i18n.amUpper : dF.i18n.pmUpper),
        Z: (utc ? "UTC" : (String(date).match(dF.timezone) || [""]).pop().replace(dF.timezoneClip, "")),
        o: (o > 0 ? "-" : "+") + dF.pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
        S: ["th", "st", "nd", "rd"][(d % 10 > 3 ? 0 : (d % 100 - d % 10 !== 10) * d % 10)],
        U: U
      };
      return mask.replace(dF.token, function($0) {
        if ($0 in flags) {
          return flags[$0];
        } else {
          return $0.slice(1, $0.length - 1);
        }
      });
    })();
  };

  return DateFormatter;

})();

chronos.PanelMonth = (function() {

  PanelMonth.name = 'PanelMonth';

  function PanelMonth(options) {
    if (options.givenDate) {
      this.givenDate = new Date(options.givenDate.valueOf());
    }
    if (options.choice) {
      this.choice = new Date(options.choice);
    }
    if (options.maxDate) {
      this.maxDate = new Date(options.maxDate.valueOf());
    }
    if (options.minDate) {
      this.minDate = new Date(options.minDate.valueOf());
    }
    this.startDay = options.startDay;
    this.dayNamesAbbr = options.dayNamesAbbr;
    this.monthNames = options.monthNames;
    this.today = new Date();
    this.container = {};
  }

  PanelMonth.prototype.render = function() {
    this.container = $("<div class='monthPanel' />");
    this.container.append(this._getMonthHeader.call(this));
    this.container.append(this._getMonthDays.call(this));
    return this.container;
  };

  /*
      Private Methods
  */


  PanelMonth.prototype._getMonthStart = function() {
    var d;
    d = new Date(this.givenDate);
    d.setDate(1);
    while (d.getDay() !== this.startDay) {
      d.setDate(d.getDate() - 1);
    }
    return d;
  };

  PanelMonth.prototype._getMonthHeader = function() {
    var d, klass, titles, value, _i, _ref, _ref1;
    titles = $('<div class="monthHeader" />');
    for (d = _i = _ref = this.startDay, _ref1 = this.startDay + 6; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; d = _ref <= _ref1 ? ++_i : --_i) {
      klass = "title day day" + (d % 7);
      value = this.dayNamesAbbr[d % 7];
      titles.append($("<div class='" + klass + "'>" + value + "</div>"));
      d++;
    }
    return titles;
  };

  PanelMonth.prototype._isToday = function(d) {
    return d.toDateString() === this.today.toDateString();
  };

  PanelMonth.prototype._isChoice = function(d) {
    if (this.choice) {
      return d.toDateString() === this.choice.toDateString();
    } else {
      return false;
    }
  };

  PanelMonth.prototype._isMonth = function(d) {
    return this.givenDate.getMonth() === d.getMonth();
  };

  PanelMonth.prototype._isAvailable = function(d) {
    if (!(this.maxDate !== void 0 || this.minDate !== void 0)) {
      return true;
    }
    if (this.maxDate && this.minDate) {
      return (d.valueOf() >= this.minDate.valueOf()) && (d.valueOf() <= this.maxDate.valueOf());
    } else if (this.maxDate) {
      return d.valueOf() <= this.maxDate.valueOf();
    } else {
      return d.valueOf() >= this.minDate.valueOf();
    }
  };

  PanelMonth.prototype._clearTimePortion = function(d) {
    d.setHours(0);
    d.setMinutes(0);
    d.setSeconds(0);
    d.setMilliseconds(0);
    return d;
  };

  PanelMonth.prototype._getMonthTitle = function() {
    return "" + this.monthNames[this.givenDate.getMonth() + 12] + " " + (this.givenDate.getFullYear());
  };

  PanelMonth.prototype._getMonthDays = function() {
    var classes, d, day, days, item, weekContainer, weekNumber, workingDate, _i, _j, _len, _ref,
      _this = this;
    _ref = [this.givenDate, this.choice, this.today, this.maxDate, this.minDate];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      if (item) {
        this._clearTimePortion(item);
      }
    }
    workingDate = this._getMonthStart();
    days = $("<div class='monthBody'                   data-date='" + (this.givenDate.valueOf()) + "'                   data-date_title='" + (this._getMonthTitle()) + "' />");
    for (d = _j = 0; _j <= 41; d = ++_j) {
      classes = ['day', 'day' + workingDate.getDay()];
      if (this._isToday(workingDate)) {
        classes.push('today');
      }
      if (this._isChoice(workingDate)) {
        classes.push('selected');
      }
      if (!this._isMonth(workingDate)) {
        classes.push('otherMonth');
      }
      if (!this._isAvailable(workingDate)) {
        classes.push('unavailable');
      }
      if (d % 7 === 0) {
        weekNumber = Math.floor(d / 7);
        weekContainer = $("<div class='week week" + weekNumber + "' />");
        days.append(weekContainer);
      }
      classes = classes.join(' ');
      day = $("<div class='" + classes + "' >" + (workingDate.getDate()) + "</div>");
      day.click({
        date: new Date(workingDate.valueOf())
      }, function(event) {
        return _this._onDaySelect(event, event.data.date);
      });
      weekContainer.append(day);
      workingDate.setDate(workingDate.getDate() + 1);
    }
    return days;
  };

  /*
      Events
  */


  PanelMonth.prototype._onDaySelect = function(event, date) {
    var $target;
    $target = $(event.target);
    if (!$target.hasClass("unavailable")) {
      return this.container.trigger('daySelected', [date, event.target]);
    }
  };

  return PanelMonth;

})();

chronos.Animator = (function() {

  Animator.name = 'Animator';

  function Animator(pickerManager, animations) {
    this.pickerManager = pickerManager;
    this.animating = false;
    this.animations = animations;
    this.$picker = void 0;
    this.$body = void 0;
    this.$next = void 0;
    this.$curr = void 0;
    this.$prev = void 0;
  }

  Animator.prototype.setPicker = function($picker) {
    this.$picker = $picker;
    return this._setElements();
  };

  Animator.prototype.previousMonth = function() {
    var animation;
    animation = this.animations.previousMonth || this._animatePreviousMonth;
    return this._animate(animation, 'previousMonthFinished');
  };

  Animator.prototype.nextMonth = function() {
    var animation;
    animation = this.animations.nextMonth || this._animateNextMonth;
    return this._animate(animation, 'nextMonthFinished');
  };

  Animator.prototype.close = function() {
    var animation;
    animation = this.animations.close || this._animateClose;
    return this._animate(animation, 'closed', true);
  };

  Animator.prototype.open = function() {
    var animation;
    animation = this.animations.open || this._animateOpen;
    return this._animate(animation, 'opened');
  };

  Animator.prototype.animationFinished = function() {
    this.animating = false;
    if (this.currentEventName) {
      this.$picker.trigger(this.currentEventName);
    }
    return this.currentEventName = null;
  };

  /*
      Private Methods
  */


  Animator.prototype._animate = function(animation, eventName, override) {
    if (override) {
      this.animating = false;
    }
    if (!this.animating) {
      this.animating = true;
      this.currentEventName = eventName;
      if ($.isFunction(animation)) {
        return animation.apply(this, [this.pickerManager]);
      }
    }
  };

  Animator.prototype._setElements = function() {
    this.$body = this.$picker.find(".body");
    this.$next = this.$body.find(".body_next");
    this.$curr = this.$body.find(".body_curr");
    return this.$prev = this.$body.find(".body_prev");
  };

  /*
      Default Animations
  */


  Animator.prototype._animatePreviousMonth = function(pickerManager) {
    var width,
      _this = this;
    pickerManager._renderTitle(this.$prev.find(".monthBody").attr('data-date_title'));
    width = this.$curr.outerWidth();
    this.$curr.animate({
      left: "+=" + width
    }, 500);
    return this.$prev.animate({
      left: "+=" + width
    }, 500, function() {
      _this._animatePreviousMonthCallback(pickerManager);
      return _this.animationFinished();
    });
  };

  Animator.prototype._animatePreviousMonthCallback = function(pickerManager) {
    var $new_prev, newCurrentDate;
    this.$next.remove();
    this.$curr.removeClass("body_curr").addClass("body_next");
    this.$prev.removeClass("body_prev").addClass("body_curr");
    $new_prev = $("<div class='body_prev' />");
    this.$body.prepend($new_prev);
    this.$curr.removeAttr('style');
    this.$prev.removeAttr('style');
    this.$next.removeAttr('style');
    newCurrentDate = new Date(parseInt(this.$prev.find(".monthBody").attr('data-date')));
    pickerManager._buildMonth(pickerManager._changeMonthBy(newCurrentDate, -1), $new_prev);
    return this._setElements();
  };

  Animator.prototype._animateNextMonth = function(pickerManager) {
    var width,
      _this = this;
    pickerManager._renderTitle(this.$next.find(".monthBody").attr('data-date_title'));
    width = this.$curr.outerWidth();
    this.$curr.animate({
      left: "-=" + width
    }, 500);
    return this.$next.animate({
      left: "-=" + width
    }, 500, function() {
      _this._animateNextMonthCallback(pickerManager);
      return _this.animationFinished();
    });
  };

  Animator.prototype._animateNextMonthCallback = function(pickerManager) {
    var $new_next, newCurrentDate;
    this.$prev.remove();
    this.$curr.removeClass("body_curr").addClass("body_prev");
    this.$next.removeClass("body_next").addClass("body_curr");
    $new_next = $("<div class='body_next' />");
    this.$body.append($new_next);
    this.$curr.removeAttr('style');
    this.$prev.removeAttr('style');
    this.$next.removeAttr('style');
    newCurrentDate = new Date(parseInt(this.$next.find(".monthBody").attr('data-date')));
    pickerManager._buildMonth(pickerManager._changeMonthBy(newCurrentDate, 1), $new_next);
    return this._setElements();
  };

  Animator.prototype._animateClose = function(pickerManager) {
    var _this = this;
    return this.$picker.animate({
      opacity: 0
    }, 300, function() {
      _this.$picker.remove();
      return _this.animationFinished();
    });
  };

  Animator.prototype._animateOpen = function(pickerManager) {
    var _this = this;
    return this.$picker.fadeIn('fast', function() {
      return _this.animationFinished();
    });
  };

  return Animator;

})();

(function($, window, document) {
  /*
      DATEPICKER PLUGIN DEFINITION
  */
  $.fn.chronos = function(options) {
    var PROP_NAME, otherArgs, _pluginSetCurrentElement;
    PROP_NAME = 'chronos';
    otherArgs = Array.prototype.slice.call(arguments, 1);
    this.each(function() {
      var $display, $element, current, element;
      element = this;
      $element = $(this);
      $display = $("#" + ($element.attr('id')) + "_display");
      current = $.data(element, PROP_NAME);
      if (typeof options === 'string') {
        if (!$.chronos[options]) {
          console.error("chronos: Unknown command: " + options);
          return null;
        } else {
          if (current) {
            if ($display.length > 0) {
              $.chronos['setCurrentElement'].apply($.chronos, [$display[0]]);
              return $.chronos[options].apply($.chronos, otherArgs);
            } else {
              return console.warn("chronos: Unknown datepicker.  Make sure id attribute is present");
            }
          } else {
            return console.warn("chronos: Unknown datepicker.");
          }
        }
      } else {
        if (!current) {
          $.chronos._attach(element, options || {});
          return $.data(element, PROP_NAME, true);
        }
      }
    });
    /*
          PUBLIC METHODS (direct access)
    
          New public methods must make sure to set the current element first through the
          pluginSetCurrentElement function.
    */

    this.setDateRange = function(range) {
      _pluginSetCurrentElement.apply(this);
      $.chronos.setDateRange(range);
      return this;
    };
    /*
          PRIVATE METHODS
    */

    _pluginSetCurrentElement = function() {
      var $display;
      $display = $("#" + (this.attr('id')) + "_display");
      if ($display.length > 0) {
        return $.chronos.setCurrentElement($display[0]);
      }
    };
    return this;
  };
  return $.chronos = new chronos.Chronos();
})(jQuery || Zepto, window, document);
